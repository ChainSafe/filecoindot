use cid::Cid;
use crate::errors::Error;

/// Verify id provided by the against the proof and the root
/// For the proof, it should be generated by the generate_proof method
/// in the HAMT mod. In this case, the root should match the
/// first element in the proof.
pub fn verify(root: &Cid, proof: Vec<Vec<u8>>, cid: &Cid) -> Result<(), Error> {
    if proof.is_empty() { return Err(Error::VerificationFailed); }
    let root_cid = root.to_bytes();
    if proof[0] != root_cid { return Err(Error::VerificationFailed); }

    let bytes = cid.to_bytes();
    match proof.iter().find(|p| **p == bytes) {
        Some(_) => Ok(()),
        None => Err(Error::VerificationFailed)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::hamt::Hamt;
    use ipld_blockstore::MemoryDB;
    use ipld_hamt::Hamt as ForestHamt;
    use crate::{ForestAdaptedBlockStorage, ForestAdaptedHashAlgo, ForestAdaptedHashedBits, ForestAdaptedNode};

    #[test]
    fn test_basic_proof_generation() {
        let bs = MemoryDB::default();
        let mut fhamt: ForestHamt<_, _, usize> = ForestHamt::new(&bs);

        let max = 1000;
        for i in 1..max {
            fhamt.set(i, i.to_string()).unwrap();
        }

        let cid = fhamt.flush().unwrap();
        let store = ForestAdaptedBlockStorage::new(bs);
        let hamt: Hamt<
            ForestAdaptedBlockStorage<MemoryDB>,
            usize,
            String,
            ForestAdaptedHashedBits,
            ForestAdaptedNode<usize, String, ForestAdaptedHashAlgo, _>,
            ForestAdaptedHashAlgo,
        > = Hamt::new(&cid, &store, 8).unwrap();

        let p = hamt.generate_proof(&1).unwrap();
        assert_eq!(verify(&cid, p.clone(), &cid).is_ok(), true);
        let not_exists = Cid::default();
        assert_eq!(verify(&cid, p, &not_exists).is_err(), true);
    }
}